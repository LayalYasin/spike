rule check_complete:
    input:
        fp_status="{prefix}%s%s{run}/ImageAnalysis_Netcopy_complete.txt" % (config['dirs']['inputs'], config['dirs']['rawillumina'])
    output:
        fp_check="{prefix}%s%s-{run}-illuminarun_complete.txt" % (config['dirs']['checks'], config['stepnames']['demultiplex'])
    log:
        "{prefix}%s%s.{run}.log" % (config['dirs']['logs'], 'check_complete')
    benchmark:
        "{prefix}%s%s.{run}.benchmark" % (config['dirs']['benchmarks'], 'check_complete')
    run:
        check_illuminarun_complete(input.fp_status, output.fp_check)


rule demultiplex:
    input:
        status="{prefix}%s%s-{run}-illuminarun_complete.txt" % (config['dirs']['checks'], config['stepnames']['demultiplex']),
        raw="{prefix}%s%s{run}" % (config['dirs']['inputs'], config['dirs']['rawillumina']),
        samplesheet="{prefix}%s%s{run}_ukd.csv" % (config['dirs']['inputs'], config['dirs']['samplesheets']),
    output:
        fastqs=directory("{prefix}%s%s/{run,[^/]+XX}" % (config['dirs']['intermediate'], config['stepnames']['demultiplex'])),
    log:
        "{prefix}%s%s.{run}.log" % (config['dirs']['logs'], config['stepnames']['demultiplex'])
    benchmark:
        "{prefix}%s%s.{run}.benchmark" % (config['dirs']['benchmarks'], config['stepnames']['demultiplex'])
    threads:
        config['num_threads']
    conda:
        "envs/spike_demux.yaml"
    shell:
        "uname -a > {log} 2>&1 &&"
        "bcl2fastq"
        " --runfolder-dir {input.raw}/"
        " --output-dir {output.fastqs}/"
        " --ignore-missing-bcls"
        " --sample-sheet {input.samplesheet}"
        " --loading-threads {threads}"
        " --processing-threads {threads}"
        " --writing-threads {threads}"
        " 2>> {log}"
        " 1>&2"
        # rename demux fastq files such that S\d+ are removed from filenames
        ' && for f in `find {output.fastqs}/ -name "*.fastq.gz"`; do fnoS=`echo "$f" | sed -r "s/_S[0-9]+_/_/"`; mv -v $f $fnoS 2>> {log} >&2; done'
        ' && cp -l -v {output.fastqs}/Reports/html/*/all/all/all/laneBarcode.html {output.fastqs}/laneBarcode.html 2>> {log} >&2'


rule aggregate_undetermined_filesizes:
    input:
        "{prefix}%s%s/{run}" % (config['dirs']['intermediate'], config['stepnames']['demultiplex'])
    output:
        sizes="{prefix}%sUndeterminedFilesizes/{run}.txt" % (config['dirs']['aggregation']),
        fp_check="{prefix}%s%s-{run}-aggregate_undetermined_filesizes.txt" % (config['dirs']['checks'], config['stepnames']['demultiplex'])
    log:
        "{prefix}%s%s.{run}.log" % (config['dirs']['logs'], 'aggregate_undetermined_filesizes')
    benchmark:
        "{prefix}%s%s.{run}.benchmark" % (config['dirs']['benchmarks'], 'aggregate_undetermined_filesizes')
    params:
        fps_undertermined="{prefix}%s%s/{run}/Undetermined_L*_001.fastq.gz" % (config['dirs']['intermediate'], config['stepnames']['demultiplex'])
    shell:
        "stat -c '%s\t%n\tunknown' {params.fps_undertermined} > {output.sizes} && "
        "echo 'done.' > {output.fp_check}"


rule check_undetermined_filesizes:
    input:
        "{prefix}%sUndeterminedFilesizes/{run}.txt" % (config['dirs']['aggregation'])
    output:
        "{prefix}%s{run}/{run}.undetermined-filesizes.pdf" % (config['dirs']['reports'])
    log:
        "{prefix}%s%s.{run}.log" % (config['dirs']['logs'], 'check_undetermined_filesizes')
    benchmark:
        "{prefix}%s%s.{run}.benchmark" % (config['dirs']['benchmarks'], 'check_undetermined_filesizes')
    run:
        report_undertermined_filesizes(input[0], output[0], os.path.join(wildcards.prefix, config['dirs']['reports'], wildcards.run, 'error_undetermined-filesizes.pdf'))


rule convert_illumina_report:
    input:
        rules.demultiplex.output.fastqs,
        undetermined=rules.check_undetermined_filesizes.output
    output:
        "{prefix}%s{run}/{run}.yield_report.pdf" % (config['dirs']['reports'])
    log:
        "{prefix}%sconvert_illumina_report.{run}.log" % (config['dirs']['logs'])
    benchmark:
        "{prefix}%sconvert_illumina_report.{run}.benchmark" % (config['dirs']['benchmarks'])
    conda:
        "envs/spike_report.yaml"
    params:
        yield_report=lambda wildcards: "%s%s%s/%s/Reports/html/%s/all/all/all/laneBarcode.html" % (wildcards.prefix, config['dirs']['intermediate'], config['stepnames']['demultiplex'], wildcards.run, wildcards.run.split('_')[-1][1:]),
        firstbase="{prefix}%s%s{run}/First_Base_Report.htm" % (config['dirs']['inputs'], config['dirs']['rawillumina']),
    shell:
        "wkhtmltopdf --orientation Landscape {params.yield_report} {output} 2> {log} &&"
        "echo 'Hi there,\n\n"
        "this is an automated message from {config[name_program]}.\n\n"
        "Demultiplexing for the flowcell mentioned in the subject line finished. Please find attached the yield report, some statistics about the file sizes of undetermined reads and the first base report.\n\n"
        "Have a nice day!' | mail -s '[{config[name_program]}] demultiplex report {wildcards.run}' {config[mail_attachment_parameter]} {output} {config[mail_attachment_parameter]} {input.undetermined} {config[mail_attachment_parameter]} {params.firstbase} {config[emails][demultiplexreport]}"
        " 2>> {log}"


rule per_sample_fastq:
    input:
        lambda wildcards: ["%s%s%s%s/%s%s.fastq.gz" % (wildcards.prefix, config['dirs']['inputs'], config['dirs']['persamplefastq'], wildcards.run, sample, direction)
                           for sample in get_persamplefastq_samples(SAMPLESHEETS, config, get='samples')
                           for direction in (config['projects'][get_persamplefastq_samples(SAMPLESHEETS, config, get='projects')[0]]['fastq']['forward'],
                                             config['projects'][get_persamplefastq_samples(SAMPLESHEETS, config, get='projects')[0]]['fastq']['reverse'])]
    output:
        fastqs=directory("{prefix}%s%s/{run,[^/]+XX}" % (config['dirs']['intermediate'], config['stepnames']['demultiplex'])),
    log:
        "{prefix}%sper_sample_fastq.{run}.log" % (config['dirs']['logs'])
    benchmark:
        "{prefix}%sper_sample_fastq.{run}.benchmark" % (config['dirs']['benchmarks'])
    run:
        project = SAMPLESHEETS[SAMPLESHEETS['run'] == wildcards.run]['Sample_Project'].iloc[0]
        map_directions = {config['projects'][project]['fastq']['forward']: 'R1',
                          config['projects'][project]['fastq']['reverse']: 'R2'}
        for fastq in input:
            #../Spike_data/Inputs/PerSampleFastq/180608_K00171_0758_HWYTJBBXX/ALL_family_LB/LB_4-2_1.fastq.gz ../Spike_data/ 180608_K00171_0758_HWYTJBBXX
            fp_input = fastq[fastq.find(wildcards.run) + len(wildcards.run)+1:-1*(len('.fastq.gz'))]
            fp_output = None
            for direction in map_directions.keys():
                if fp_input.endswith(direction):
                    fp_output = fp_input[:-1*len(direction)] + '_L000_' + map_directions[direction] + '_001.fastq.gz'
                    break

            fp_input = '%s%s%s%s/%s.fastq.gz' % (wildcards.prefix, config['dirs']['inputs'], config['dirs']['persamplefastq'], wildcards.run, fp_input)
            fp_output = '%s%s%s/%s/%s' % (wildcards.prefix, config['dirs']['intermediate'], config['stepnames']['demultiplex'], wildcards.run, fp_output)

            os.makedirs(os.path.dirname(fp_output), exist_ok=True)
            os.link(fp_input, fp_output)
